# ADR 001: Render Deployment Architecture

## Status
Accepted

## Context
HarborX platform requires a production deployment solution that provides:
- Auto-deployment on git push
- Managed infrastructure (no DevOps overhead)
- Easy environment variable management
- Built-in PostgreSQL and Redis
- HTTPS/SSL out of the box
- Health check monitoring
- Zero-downtime deployments

We need to deploy three services:
1. **Web Service**: Next.js frontend
2. **Auth Service**: FastAPI authentication/authorization
3. **Core Service**: FastAPI business logic

## Decision
We will deploy HarborX platform on Render.com using their Blueprint specification.

### Architecture Components

#### 1. Services
- **harborx-web** (Next.js)
  - Serves the frontend application
  - Communicates with backend via NEXT_PUBLIC_API_URL
  - Health check: `/api/health`
  - Port: 10000 (Render default)

- **harborx-auth** (FastAPI)
  - Handles authentication and authorization
  - JWT token generation and validation
  - Health check: `/health`
  - Port: 10000

- **harborx-core** (FastAPI)
  - Core business logic and API endpoints
  - Communicates with auth service for validation
  - Health check: `/health`
  - Port: 10000

#### 2. Databases
- **PostgreSQL**: Shared database for auth and core services
- **Redis**: Caching and session management

#### 3. Environment Variables Strategy

**Public Variables** (can be in code):
- PORT, NODE_ENV, ENVIRONMENT
- Default values in .env.example files

**Secrets** (only in Render dashboard):
- JWT_SECRET_KEY (auto-generated by Render)
- DATABASE_URL (auto-injected from database)
- REDIS_URL (auto-injected from Redis service)
- NEXT_PUBLIC_API_URL (set manually to core service URL)
- CORS_ORIGINS (set manually to web service URL)
- AUTH_SERVICE_URL (set manually to auth service URL)

**Security Principles**:
- Never commit secrets to repository
- Use Render's `generateValue: true` for sensitive keys
- Use `fromDatabase` and `fromService` for automatic injection
- Use `sync: false` for values that must be set manually in dashboard

#### 4. Deployment Flow
```
Developer Push → GitHub → Render Webhook → Build → Deploy → Health Check → Live
```

- Push to `main` branch triggers automatic deployment
- Each service builds independently
- Health checks must pass before marking service as "live"
- Old version stays running until new version is healthy (zero-downtime)

#### 5. Health Checks
All services expose health check endpoints:
- Returns 200 OK when healthy
- Includes service name, status, timestamp
- Used by Render for deployment validation
- Used by load balancers for traffic routing

## Consequences

### Positive
- **Fast Setup**: Blueprint YAML defines entire infrastructure
- **Auto-Deploy**: Push to main = automatic deployment
- **Managed Services**: No server management, automatic SSL, monitoring
- **Cost-Effective**: Free tier available, pay-as-you-grow
- **Zero Secrets in Repo**: All secrets managed in Render dashboard
- **Easy Rollback**: Render UI allows instant rollback to previous versions

### Negative
- **Vendor Lock-in**: Render-specific configuration (mitigated by standard Docker/buildpack deployment)
- **Cold Starts**: Free tier services may have cold start delays
- **Resource Limits**: Free tier has limited CPU/memory
- **Manual Dashboard Config**: Some env vars require manual setup in Render dashboard

### Risks
1. **Service Communication**: Services must use correct URLs to communicate
   - **Mitigation**: Document URL patterns, use environment variables
   
2. **Database Connection Limits**: PostgreSQL starter plan has connection limits
   - **Mitigation**: Use connection pooling, monitor connection usage
   
3. **CORS Issues**: Frontend may face CORS errors if not configured properly
   - **Mitigation**: Set CORS_ORIGINS correctly in each service

## Rollback Strategy
1. **Instant Rollback**: Use Render dashboard to rollback to previous deployment
2. **Manual Deployment**: Deploy specific commit via Render dashboard
3. **Git Revert**: Revert commit and push to trigger new deployment
4. **render.yaml Versioning**: Keep render.yaml in git for infrastructure rollback

## Monitoring and Observability
- **Health Checks**: All services expose /health endpoints
- **Render Logs**: Access logs via Render dashboard
- **Metrics**: Render provides basic CPU/memory metrics
- **Alerts**: Configure alerts in Render for service failures

## Implementation Steps
1. ✅ Create service directory structure
2. ✅ Add health check endpoints to all services
3. ✅ Create render.yaml Blueprint
4. ✅ Create .env.example files for local development
5. ⏳ Connect GitHub repository to Render
6. ⏳ Configure environment variables in Render dashboard
7. ⏳ Deploy and verify services

## References
- [Render Blueprint Specification](https://render.com/docs/blueprint-spec)
- [Render Environment Variables](https://render.com/docs/environment-variables)
- [FastAPI Deployment](https://fastapi.tiangolo.com/deployment/)
- [Next.js Deployment](https://nextjs.org/docs/deployment)
